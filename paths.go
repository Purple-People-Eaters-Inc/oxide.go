// Code generated by `generate`. DO NOT EDIT.

package oxide

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
)

// HardwareRacksGet
//
// List racks in the system.
//
// To iterate over all pages, use the `HardwareRacksGetAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
func (c *Client) HardwareRacksGet(limit int, pageToken string, sortBy IDSortMode) (*RackResultsPage, error) {
	// Create the url.
	path := "/hardware/racks"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
		"sortBy":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RackResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// HardwareRacksGetAllPages
//
// List racks in the system.
//
// This method is a wrapper around the `HardwareRacksGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (c *Client) HardwareRacksGetAllPages(sortBy IDSortMode) (*[]Rack, error) {

	var allPages []Rack
	pageToken := ""
	limit := 100
	for {
		page, err := c.HardwareRacksGet(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // HardwareRacksGetRack
//
// Fetch information about a particular rack.
//
// Parameters:
//	- `rackId`
func (c *Client) HardwareRacksGetRack(rackId string) (*Rack, error) {
	// Create the url.
	path := "/hardware/racks/{{.rack_id}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"rackId": rackId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Rack
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// HardwareSledsGet
//
// List sleds in the system.
//
// To iterate over all pages, use the `HardwareSledsGetAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
func (c *Client) HardwareSledsGet(limit int, pageToken string, sortBy IDSortMode) (*SledResultsPage, error) {
	// Create the url.
	path := "/hardware/sleds"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
		"sortBy":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SledResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// HardwareSledsGetAllPages
//
// List sleds in the system.
//
// This method is a wrapper around the `HardwareSledsGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (c *Client) HardwareSledsGetAllPages(sortBy IDSortMode) (*[]Sled, error) {

	var allPages []Sled
	pageToken := ""
	limit := 100
	for {
		page, err := c.HardwareSledsGet(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // HardwareSledsGetSled
//
// Fetch information about a sled in the system.
//
// Parameters:
//	- `sledId`
func (c *Client) HardwareSledsGetSled(sledId string) (*Sled, error) {
	// Create the url.
	path := "/hardware/sleds/{{.sled_id}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sledId": sledId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Sled
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// SpoofLogin
func (c *Client) SpoofLogin(j *LoginParams) error {
	// Create the url.
	path := "/login"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// Logout
func (c *Client) Logout() error {
	// Create the url.
	path := "/logout"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// OrganizationsGet
//
// List all organizations.
//
// To iterate over all pages, use the `OrganizationsGetAllPages` method, instead.
//
// Parameters:
//	- `pageToken`
//	- `sortBy`
//	- `limit`
func (c *Client) OrganizationsGet(limit int, pageToken string, sortBy NameOrIdSortMode) (*OrganizationResultsPage, error) {
	// Create the url.
	path := "/organizations"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
		"sortBy":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body OrganizationResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// OrganizationsGetAllPages
//
// List all organizations.
//
// This method is a wrapper around the `OrganizationsGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (c *Client) OrganizationsGetAllPages(sortBy NameOrIdSortMode) (*[]Organization, error) {

	var allPages []Organization
	pageToken := ""
	limit := 100
	for {
		page, err := c.OrganizationsGet(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // OrganizationsPost
//
// Create a new organization.
func (c *Client) OrganizationsPost(j *OrganizationCreate) (*Organization, error) {
	// Create the url.
	path := "/organizations"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// OrganizationsGetOrganization
//
// Fetch a specific organization
//
// Parameters:
//	- `organizationName`
func (c *Client) OrganizationsGetOrganization(organizationName Name) (*Organization, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// OrganizationsPutOrganization
//
// Update a specific organization.
//  * TODO-correctness: Is it valid for PUT to accept application/json that's a subset of what the resource actually represents?  If not, is that a problem? (HTTP may require that this be idempotent.)  If so, can we get around that having this be a slightly different content-type (e.g., "application/json-patch")?  We should see what other APIs do.
//
// Parameters:
//	- `organizationName`
func (c *Client) OrganizationsPutOrganization(organizationName Name, j *OrganizationUpdate) (*Organization, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// OrganizationsDeleteOrganization
//
// Delete a specific organization.
//
// Parameters:
//	- `organizationName`
func (c *Client) OrganizationsDeleteOrganization(organizationName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// OrganizationProjectsGet
//
// List all projects.
//
// To iterate over all pages, use the `OrganizationProjectsGetAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
//	- `organizationName`
func (c *Client) OrganizationProjectsGet(limit int, pageToken string, sortBy NameOrIdSortMode, organizationName Name) (*ProjectResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"sortBy":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ProjectResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// OrganizationProjectsGetAllPages
//
// List all projects.
//
// This method is a wrapper around the `OrganizationProjectsGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
//	- `organizationName`
func (c *Client) OrganizationProjectsGetAllPages(sortBy NameOrIdSortMode, organizationName Name) (*[]Project, error) {

	var allPages []Project
	pageToken := ""
	limit := 100
	for {
		page, err := c.OrganizationProjectsGet(limit, pageToken, sortBy, organizationName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // OrganizationProjectsPost
//
// Create a new project.
//
// Parameters:
//	- `organizationName`
func (c *Client) OrganizationProjectsPost(organizationName Name, j *ProjectCreate) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// OrganizationProjectsGetProject
//
// Fetch a specific project
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (c *Client) OrganizationProjectsGetProject(organizationName Name, projectName Name) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// OrganizationProjectsPutProject
//
// Update a specific project.
//  * TODO-correctness: Is it valid for PUT to accept application/json that's a subset of what the resource actually represents?  If not, is that a problem? (HTTP may require that this be idempotent.)  If so, can we get around that having this be a slightly different content-type (e.g., "application/json-patch")?  We should see what other APIs do.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (c *Client) OrganizationProjectsPutProject(organizationName Name, projectName Name, j *ProjectUpdate) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// OrganizationProjectsDeleteProject
//
// Delete a specific project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (c *Client) OrganizationProjectsDeleteProject(organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// ProjectDisksGet
//
// List disks in a project.
//
// To iterate over all pages, use the `ProjectDisksGetAllPages` method, instead.
//
// Parameters:
//	- `projectName`
//	- `limit`
//	- `pageToken`
//	- `sortBy`
//	- `organizationName`
func (c *Client) ProjectDisksGet(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*DiskResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectDisksGetAllPages
//
// List disks in a project.
//
// This method is a wrapper around the `ProjectDisksGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectDisksGetAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Disk, error) {

	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := c.ProjectDisksGet(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // ProjectDisksPost
//
// Create a disk in a project.
//  * TODO-correctness See note about instance create.  This should be async.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectDisksPost(organizationName Name, projectName Name, j *DiskCreate) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectDisksGetDisk
//
// Fetch a single disk in a project.
//
// Parameters:
//	- `projectName`
//	- `diskName`
//	- `organizationName`
func (c *Client) ProjectDisksGetDisk(diskName Name, organizationName Name, projectName Name) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"diskName":         string(diskName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectDisksDeleteDisk
//
// Delete a disk from a project.
//
// Parameters:
//	- `projectName`
//	- `diskName`
//	- `organizationName`
func (c *Client) ProjectDisksDeleteDisk(diskName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"diskName":         string(diskName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// ProjectInstancesGet
//
// List instances in a project.
//
// To iterate over all pages, use the `ProjectInstancesGetAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectInstancesGet(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*InstanceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body InstanceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectInstancesGetAllPages
//
// List instances in a project.
//
// This method is a wrapper around the `ProjectInstancesGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectInstancesGetAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Instance, error) {

	var allPages []Instance
	pageToken := ""
	limit := 100
	for {
		page, err := c.ProjectInstancesGet(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // ProjectInstancesPost
//
// Create an instance in a project.
//  * TODO-correctness This is supposed to be async.  Is that right?  We can create the instance immediately -- it's just not booted yet.  Maybe the boot operation is what's a separate operation_id.  What about the response code (201 Created vs 202 Accepted)?  Is that orthogonal?  Things can return a useful response, including an operation id, with either response code.  Maybe a "reboot" operation would return a 202 Accepted because there's no actual resource created?
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectInstancesPost(organizationName Name, projectName Name, j *InstanceCreate) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectInstancesGetInstance
//
// Get an instance in a project.
//
// Parameters:
//	- `projectName`
//	- `instanceName`
//	- `organizationName`
func (c *Client) ProjectInstancesGetInstance(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectInstancesDeleteInstance
//
// Delete an instance from a project.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectInstancesDeleteInstance(instanceName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// InstanceDisksGet
//
// List disks attached to this instance.
//
// To iterate over all pages, use the `InstanceDisksGetAllPages` method, instead.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `limit`
//	- `pageToken`
//	- `sortBy`
//	- `instanceName`
func (c *Client) InstanceDisksGet(limit int, pageToken string, sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*DiskResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// InstanceDisksGetAllPages
//
// List disks attached to this instance.
//
// This method is a wrapper around the `InstanceDisksGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (c *Client) InstanceDisksGetAllPages(sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*[]Disk, error) {

	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := c.InstanceDisksGet(limit, pageToken, sortBy, instanceName, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // InstanceDisksAttach
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (c *Client) InstanceDisksAttach(instanceName Name, organizationName Name, projectName Name, j *DiskIdentifier) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks/attach"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// InstanceDisksDetach
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (c *Client) InstanceDisksDetach(instanceName Name, organizationName Name, projectName Name, j *DiskIdentifier) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks/detach"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectInstancesInstanceReboot
//
// Reboot an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectInstancesInstanceReboot(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/reboot"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectInstancesInstanceStart
//
// Boot an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectInstancesInstanceStart(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/start"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectInstancesInstanceStop
//
// Halt an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectInstancesInstanceStop(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/stop"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectVpcsGet
//
// List VPCs in a project.
//
// To iterate over all pages, use the `ProjectVpcsGetAllPages` method, instead.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `limit`
//	- `pageToken`
//	- `sortBy`
func (c *Client) ProjectVpcsGet(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*VPCResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectVpcsGetAllPages
//
// List VPCs in a project.
//
// This method is a wrapper around the `ProjectVpcsGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectVpcsGetAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]VPC, error) {

	var allPages []VPC
	pageToken := ""
	limit := 100
	for {
		page, err := c.ProjectVpcsGet(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // ProjectVpcsPost
//
// Create a VPC in a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectVpcsPost(organizationName Name, projectName Name, j *VPCCreate) (*VPC, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPC
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectVpcsGetVpc
//
// Get a VPC in a project.
//
// Parameters:
//	- `vpcName`
//	- `organizationName`
//	- `projectName`
func (c *Client) ProjectVpcsGetVpc(organizationName Name, projectName Name, vpcName Name) (*VPC, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPC
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ProjectVpcsPutVpc
//
// Update a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (c *Client) ProjectVpcsPutVpc(organizationName Name, projectName Name, vpcName Name, j *VPCUpdate) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// ProjectVpcsDeleteVpc
//
// Delete a vpc from a project.
//
// Parameters:
//	- `projectName`
//	- `vpcName`
//	- `organizationName`
func (c *Client) ProjectVpcsDeleteVpc(organizationName Name, projectName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// VpcFirewallRulesGet
//
// List firewall rules for a VPC.
//
// To iterate over all pages, use the `VpcFirewallRulesGetAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (c *Client) VpcFirewallRulesGet(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*VPCFirewallRuleResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/firewall/rules"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCFirewallRuleResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VpcFirewallRulesGetAllPages
//
// List firewall rules for a VPC.
//
// This method is a wrapper around the `VpcFirewallRulesGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (c *Client) VpcFirewallRulesGetAllPages(sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*[]VPCFirewallRule, error) {

	var allPages []VPCFirewallRule
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcFirewallRulesGet(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // VpcFirewallRulesPut
//
// Replace the firewall rules for a VPC
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (c *Client) VpcFirewallRulesPut(organizationName Name, projectName Name, vpcName Name, j *VPCFirewallRuleUpdateParams) (*VPCFirewallRuleUpdateResult, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/firewall/rules"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCFirewallRuleUpdateResult
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VpcRoutersGet
//
// List VPC Custom and System Routers
//
// To iterate over all pages, use the `VpcRoutersGetAllPages` method, instead.
//
// Parameters:
//	- `vpcName`
//	- `limit`
//	- `pageToken`
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
func (c *Client) VpcRoutersGet(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*VPCRouterResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCRouterResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VpcRoutersGetAllPages
//
// List VPC Custom and System Routers
//
// This method is a wrapper around the `VpcRoutersGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (c *Client) VpcRoutersGetAllPages(sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*[]VPCRouter, error) {

	var allPages []VPCRouter
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcRoutersGet(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // VpcRoutersPost
//
// Create a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (c *Client) VpcRoutersPost(organizationName Name, projectName Name, vpcName Name, j *VPCRouterCreate) (*VPCRouter, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VpcRoutersGetRouter
//
// Get a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (c *Client) VpcRoutersGetRouter(organizationName Name, projectName Name, routerName Name, vpcName Name) (*VPCRouter, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VpcRoutersPutRouter
//
// Update a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (c *Client) VpcRoutersPutRouter(organizationName Name, projectName Name, routerName Name, vpcName Name, j *VPCRouterUpdate) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// VpcRoutersDeleteRouter
//
// Delete a router from its VPC
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (c *Client) VpcRoutersDeleteRouter(organizationName Name, projectName Name, routerName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// RoutersRoutesGet
//
// List a Router's routes
//
// To iterate over all pages, use the `RoutersRoutesGetAllPages` method, instead.
//
// Parameters:
//	- `routerName`
//	- `vpcName`
//	- `limit`
//	- `pageToken`
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
func (c *Client) RoutersRoutesGet(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, routerName Name, vpcName Name) (*RouterRouteResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"routerName":       string(routerName),
		"sortBy":           string(sortBy),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterRouteResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// RoutersRoutesGetAllPages
//
// List a Router's routes
//
// This method is a wrapper around the `RoutersRoutesGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (c *Client) RoutersRoutesGetAllPages(sortBy NameSortMode, organizationName Name, projectName Name, routerName Name, vpcName Name) (*[]RouterRoute, error) {

	var allPages []RouterRoute
	pageToken := ""
	limit := 100
	for {
		page, err := c.RoutersRoutesGet(limit, pageToken, sortBy, organizationName, projectName, routerName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // RoutersRoutesPost
//
// Create a VPC Router
//
// Parameters:
//	- `projectName`
//	- `routerName`
//	- `vpcName`
//	- `organizationName`
func (c *Client) RoutersRoutesPost(organizationName Name, projectName Name, routerName Name, vpcName Name, j *RouterRouteCreateParams) (*RouterRoute, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// RoutersRoutesGetRoute
//
// Get a VPC Router route
//
// Parameters:
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
//	- `organizationName`
func (c *Client) RoutersRoutesGetRoute(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name) (*RouterRoute, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routeName":        string(routeName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// RoutersRoutesPutRoute
//
// Update a Router route
//
// Parameters:
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
//	- `organizationName`
func (c *Client) RoutersRoutesPutRoute(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name, j *RouterRouteUpdateParams) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routeName":        string(routeName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// RoutersRoutesDeleteRoute
//
// Delete a route from its router
//
// Parameters:
//	- `vpcName`
//	- `organizationName`
//	- `projectName`
//	- `routeName`
//	- `routerName`
func (c *Client) RoutersRoutesDeleteRoute(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routeName":        string(routeName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// VpcSubnetsGet
//
// List subnets in a VPC.
//
// To iterate over all pages, use the `VpcSubnetsGetAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (c *Client) VpcSubnetsGet(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*VPCSubnetResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCSubnetResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VpcSubnetsGetAllPages
//
// List subnets in a VPC.
//
// This method is a wrapper around the `VpcSubnetsGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (c *Client) VpcSubnetsGetAllPages(sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*[]VPCSubnet, error) {

	var allPages []VPCSubnet
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcSubnetsGet(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // VpcSubnetsPost
//
// Create a subnet in a VPC.
//
// Parameters:
//	- `vpcName`
//	- `organizationName`
//	- `projectName`
func (c *Client) VpcSubnetsPost(organizationName Name, projectName Name, vpcName Name, j *VPCSubnetCreate) (*VPCSubnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VpcSubnetsGetSubnet
//
// Get subnet in a VPC.
//
// Parameters:
//	- `subnetName`
//	- `vpcName`
//	- `organizationName`
//	- `projectName`
func (c *Client) VpcSubnetsGetSubnet(organizationName Name, projectName Name, subnetName Name, vpcName Name) (*VPCSubnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"subnetName":       string(subnetName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VpcSubnetsPutSubnet
//
// Update a VPC Subnet.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (c *Client) VpcSubnetsPutSubnet(organizationName Name, projectName Name, subnetName Name, vpcName Name, j *VPCSubnetUpdate) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(c.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"subnetName":       string(subnetName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// VpcSubnetsDeleteSubnet
//
// Delete a subnet from a VPC.
//
// Parameters:
//	- `subnetName`
//	- `vpcName`
//	- `organizationName`
//	- `projectName`
func (c *Client) VpcSubnetsDeleteSubnet(organizationName Name, projectName Name, subnetName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"subnetName":       string(subnetName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// SubnetsIpsGet
//
// List IP addresses on a VPC subnet.
//
// To iterate over all pages, use the `SubnetsIpsGetAllPages` method, instead.
//
// Parameters:
//	- `subnetName`
//	- `vpcName`
//	- `limit`
//	- `pageToken`
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
func (c *Client) SubnetsIpsGet(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, subnetName Name, vpcName Name) (*NetworkInterfaceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}/ips"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
		"subnetName":       string(subnetName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// SubnetsIpsGetAllPages
//
// List IP addresses on a VPC subnet.
//
// This method is a wrapper around the `SubnetsIpsGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (c *Client) SubnetsIpsGetAllPages(sortBy NameSortMode, organizationName Name, projectName Name, subnetName Name, vpcName Name) (*[]NetworkInterface, error) {

	var allPages []NetworkInterface
	pageToken := ""
	limit := 100
	for {
		page, err := c.SubnetsIpsGet(limit, pageToken, sortBy, organizationName, projectName, subnetName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // RolesGet
//
// List the built-in roles
//
// To iterate over all pages, use the `RolesGetAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
func (c *Client) RolesGet(limit int, pageToken string) (*RoleResultsPage, error) {
	// Create the url.
	path := "/roles"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RoleResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// RolesGetAllPages
//
// List the built-in roles
//
// This method is a wrapper around the `RolesGet` method.
// This method returns all the pages at once.
func (c *Client) RolesGetAllPages() (*[]Role, error) {

	var allPages []Role
	pageToken := ""
	limit := 100
	for {
		page, err := c.RolesGet(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // RolesGetRole
//
// Fetch a specific built-in role
//
// Parameters:
//	- `roleName`
func (c *Client) RolesGetRole(roleName string) (*Role, error) {
	// Create the url.
	path := "/roles/{{.role_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"roleName": roleName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Role
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// SagasGet
//
// List all sagas (for debugging)
//
// To iterate over all pages, use the `SagasGetAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
func (c *Client) SagasGet(limit int, pageToken string, sortBy IDSortMode) (*SagaResultsPage, error) {
	// Create the url.
	path := "/sagas"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
		"sortBy":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SagaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// SagasGetAllPages
//
// List all sagas (for debugging)
//
// This method is a wrapper around the `SagasGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (c *Client) SagasGetAllPages(sortBy IDSortMode) (*[]Saga, error) {

	var allPages []Saga
	pageToken := ""
	limit := 100
	for {
		page, err := c.SagasGet(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // SagasGetSaga
//
// Fetch information about a single saga (for debugging)
//
// Parameters:
//	- `sagaId`
func (c *Client) SagasGetSaga(sagaId string) (*Saga, error) {
	// Create the url.
	path := "/sagas/{{.saga_id}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sagaId": sagaId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Saga
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// SessionMe
//
// Fetch the user associated with the current session
func (c *Client) SessionMe() (*SessionUser, error) {
	// Create the url.
	path := "/session/me"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SessionUser
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// TimeseriesSchemaGet
//
// List all timeseries schema
//
// To iterate over all pages, use the `TimeseriesSchemaGetAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
func (c *Client) TimeseriesSchemaGet(limit int, pageToken string) (*TimeseriesSchemaResultsPage, error) {
	// Create the url.
	path := "/timeseries/schema"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body TimeseriesSchemaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// TimeseriesSchemaGetAllPages
//
// List all timeseries schema
//
// This method is a wrapper around the `TimeseriesSchemaGet` method.
// This method returns all the pages at once.
func (c *Client) TimeseriesSchemaGetAllPages() (*[]TimeseriesSchema, error) {

	var allPages []TimeseriesSchema
	pageToken := ""
	limit := 100
	for {
		page, err := c.TimeseriesSchemaGet(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // UsersGet
//
// List the built-in system users
//
// To iterate over all pages, use the `UsersGetAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
func (c *Client) UsersGet(limit int, pageToken string, sortBy NameSortMode) (*UserResultsPage, error) {
	// Create the url.
	path := "/users"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
		"sortBy":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// UsersGetAllPages
//
// List the built-in system users
//
// This method is a wrapper around the `UsersGet` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (c *Client) UsersGetAllPages(sortBy NameSortMode) (*[]User, error) {

	var allPages []User
	pageToken := ""
	limit := 100
	for {
		page, err := c.UsersGet(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // UsersGetUser
//
// Fetch a specific built-in system user
//
// Parameters:
//	- `userName`
func (c *Client) UsersGetUser(userName Name) (*User, error) {
	// Create the url.
	path := "/users/{{.user_name}}"
	uri := resolveRelative(c.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"userName": string(userName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

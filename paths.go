// Code generated by `generate`. DO NOT EDIT.

package oxide

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
)

// RacksList
//
// List racks in the system.
//
// To iterate over all pages, use the `RacksListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
func (s *HardwareService) RacksList(limit int, pageToken string, sortBy IDSortMode) (*RackResultsPage, error) {
	// Create the url.
	path := "/hardware/racks"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
		"sortBy":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RackResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// RacksListAllPages
//
// List racks in the system.
//
// This method is a wrapper around the `RacksList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *HardwareService) RacksListAllPages(sortBy IDSortMode) (*[]Rack, error) {

	var allPages []Rack
	pageToken := ""
	limit := 100
	for {
		page, err := s.RacksList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // RacksGetRack
//
// Fetch information about a particular rack.
//
// Parameters:
//	- `rackId`
func (s *HardwareService) RacksGetRack(rackId string) (*Rack, error) {
	// Create the url.
	path := "/hardware/racks/{{.rack_id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"rackId": rackId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Rack
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// SledsList
//
// List sleds in the system.
//
// To iterate over all pages, use the `SledsListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
func (s *HardwareService) SledsList(limit int, pageToken string, sortBy IDSortMode) (*SledResultsPage, error) {
	// Create the url.
	path := "/hardware/sleds"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
		"sortBy":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SledResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// SledsListAllPages
//
// List sleds in the system.
//
// This method is a wrapper around the `SledsList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *HardwareService) SledsListAllPages(sortBy IDSortMode) (*[]Sled, error) {

	var allPages []Sled
	pageToken := ""
	limit := 100
	for {
		page, err := s.SledsList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // SledsGetSled
//
// Fetch information about a sled in the system.
//
// Parameters:
//	- `sledId`
func (s *HardwareService) SledsGetSled(sledId string) (*Sled, error) {
	// Create the url.
	path := "/hardware/sleds/{{.sled_id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sledId": sledId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Sled
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List
//
// List all organizations.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
func (s *OrganizationsService) List(limit int, pageToken string, sortBy NameOrIdSortMode) (*OrganizationResultsPage, error) {
	// Create the url.
	path := "/organizations"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
		"sortBy":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body OrganizationResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages
//
// List all organizations.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *OrganizationsService) ListAllPages(sortBy NameOrIdSortMode) (*[]Organization, error) {

	var allPages []Organization
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create
//
// Create a new organization.
func (s *OrganizationsService) Create(j *OrganizationCreate) (*Organization, error) {
	// Create the url.
	path := "/organizations"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get
//
// Fetch a specific organization
//
// Parameters:
//	- `organizationName`
func (s *OrganizationsService) Get(organizationName Name) (*Organization, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put
//
// Update a specific organization.
//  * TODO-correctness: Is it valid for PUT to accept application/json that's a subset of what the resource actually represents?  If not, is that a problem? (HTTP may require that this be idempotent.)  If so, can we get around that having this be a slightly different content-type (e.g., "application/json-patch")?  We should see what other APIs do.
//
// Parameters:
//	- `organizationName`
func (s *OrganizationsService) Put(organizationName Name, j *OrganizationUpdate) (*Organization, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete
//
// Delete a specific organization.
//
// Parameters:
//	- `organizationName`
func (s *OrganizationsService) Delete(organizationName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List
//
// List all projects.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `organizationName`
//	- `pageToken`
//	- `sortBy`
func (s *ProjectsService) List(limit int, pageToken string, sortBy NameOrIdSortMode, organizationName Name) (*ProjectResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"sortBy":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ProjectResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages
//
// List all projects.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `sortBy`
func (s *ProjectsService) ListAllPages(sortBy NameOrIdSortMode, organizationName Name) (*[]Project, error) {

	var allPages []Project
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create
//
// Create a new project.
//
// Parameters:
//	- `organizationName`
func (s *ProjectsService) Create(organizationName Name, j *ProjectCreate) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get
//
// Fetch a specific project
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (s *ProjectsService) Get(organizationName Name, projectName Name) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// PutProject
//
// Update a specific project.
//  * TODO-correctness: Is it valid for PUT to accept application/json that's a subset of what the resource actually represents?  If not, is that a problem? (HTTP may require that this be idempotent.)  If so, can we get around that having this be a slightly different content-type (e.g., "application/json-patch")?  We should see what other APIs do.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (s *OrganizationsService) PutProject(organizationName Name, projectName Name, j *ProjectUpdate) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete
//
// Delete a specific project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (s *ProjectsService) Delete(organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// DisksList
//
// List disks in a project.
//
// To iterate over all pages, use the `DisksListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `organizationName`
//	- `pageToken`
//	- `projectName`
//	- `sortBy`
func (s *ProjectsService) DisksList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*DiskResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DisksListAllPages
//
// List disks in a project.
//
// This method is a wrapper around the `DisksList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
func (s *ProjectsService) DisksListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Disk, error) {

	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := s.DisksList(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // DisksCreate
//
// Create a disk in a project.
//  * TODO-correctness See note about instance create.  This should be async.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (s *ProjectsService) DisksCreate(organizationName Name, projectName Name, j *DiskCreate) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DisksGetDisk
//
// Fetch a single disk in a project.
//
// Parameters:
//	- `diskName`
//	- `organizationName`
//	- `projectName`
func (s *ProjectsService) DisksGetDisk(diskName Name, organizationName Name, projectName Name) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"diskName":         string(diskName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DisksDeleteDisk
//
// Delete a disk from a project.
//
// Parameters:
//	- `diskName`
//	- `organizationName`
//	- `projectName`
func (s *ProjectsService) DisksDeleteDisk(diskName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"diskName":         string(diskName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List
//
// List instances in a project.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `organizationName`
//	- `pageToken`
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) List(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*InstanceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body InstanceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages
//
// List instances in a project.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) ListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Instance, error) {

	var allPages []Instance
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create
//
// Create an instance in a project.
//  * TODO-correctness This is supposed to be async.  Is that right?  We can create the instance immediately -- it's just not booted yet.  Maybe the boot operation is what's a separate operation_id.  What about the response code (201 Created vs 202 Accepted)?  Is that orthogonal?  Things can return a useful response, including an operation id, with either response code.  Maybe a "reboot" operation would return a 202 Accepted because there's no actual resource created?
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Create(organizationName Name, projectName Name, j *InstanceCreate) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get
//
// Get an instance in a project.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Get(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete
//
// Delete an instance from a project.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Delete(instanceName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// DisksList
//
// List disks attached to this instance.
//
// To iterate over all pages, use the `DisksListAllPages` method, instead.
//
// Parameters:
//	- `instanceName`
//	- `limit`
//	- `organizationName`
//	- `pageToken`
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) DisksList(limit int, pageToken string, sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*DiskResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DisksListAllPages
//
// List disks attached to this instance.
//
// This method is a wrapper around the `DisksList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) DisksListAllPages(sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*[]Disk, error) {

	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := s.DisksList(limit, pageToken, sortBy, instanceName, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // DisksAttach
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) DisksAttach(instanceName Name, organizationName Name, projectName Name, j *DiskIdentifier) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks/attach"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DisksDetach
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) DisksDetach(instanceName Name, organizationName Name, projectName Name, j *DiskIdentifier) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks/detach"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Reboot
//
// Reboot an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Reboot(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/reboot"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Start
//
// Boot an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Start(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/start"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Stop
//
// Halt an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Stop(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/stop"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instanceName":     string(instanceName),
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCsList
//
// List VPCs in a project.
//
// To iterate over all pages, use the `VPCsListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `organizationName`
//	- `pageToken`
//	- `projectName`
//	- `sortBy`
func (s *NetworkingService) VPCsList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*VPCResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCsListAllPages
//
// List VPCs in a project.
//
// This method is a wrapper around the `VPCsList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
func (s *NetworkingService) VPCsListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]VPC, error) {

	var allPages []VPC
	pageToken := ""
	limit := 100
	for {
		page, err := s.VPCsList(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // VPCsCreate
//
// Create a VPC in a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
func (s *NetworkingService) VPCsCreate(organizationName Name, projectName Name, j *VPCCreate) (*VPC, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPC
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCsGetVPC
//
// Get a VPC in a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *NetworkingService) VPCsGetVPC(organizationName Name, projectName Name, vpcName Name) (*VPC, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPC
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCsPutVPC
//
// Update a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *NetworkingService) VPCsPutVPC(organizationName Name, projectName Name, vpcName Name, j *VPCUpdate) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// VPCsDeleteVPC
//
// Delete a vpc from a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *NetworkingService) VPCsDeleteVPC(organizationName Name, projectName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// VPCFirewallRulesList
//
// List firewall rules for a VPC.
//
// To iterate over all pages, use the `VPCFirewallRulesListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `organizationName`
//	- `pageToken`
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *NetworkingService) VPCFirewallRulesList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*VPCFirewallRuleResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/firewall/rules"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCFirewallRuleResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCFirewallRulesListAllPages
//
// List firewall rules for a VPC.
//
// This method is a wrapper around the `VPCFirewallRulesList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *NetworkingService) VPCFirewallRulesListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*[]VPCFirewallRule, error) {

	var allPages []VPCFirewallRule
	pageToken := ""
	limit := 100
	for {
		page, err := s.VPCFirewallRulesList(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // VPCFirewallRulesPut
//
// Replace the firewall rules for a VPC
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *NetworkingService) VPCFirewallRulesPut(organizationName Name, projectName Name, vpcName Name, j *VPCFirewallRuleUpdateParams) (*VPCFirewallRuleUpdateResult, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/firewall/rules"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCFirewallRuleUpdateResult
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCRoutersList
//
// List VPC Custom and System Routers
//
// To iterate over all pages, use the `VPCRoutersListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `organizationName`
//	- `pageToken`
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *NetworkingService) VPCRoutersList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*VPCRouterResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCRouterResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCRoutersListAllPages
//
// List VPC Custom and System Routers
//
// This method is a wrapper around the `VPCRoutersList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *NetworkingService) VPCRoutersListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*[]VPCRouter, error) {

	var allPages []VPCRouter
	pageToken := ""
	limit := 100
	for {
		page, err := s.VPCRoutersList(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // VPCRoutersCreate
//
// Create a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *NetworkingService) VPCRoutersCreate(organizationName Name, projectName Name, vpcName Name, j *VPCRouterCreate) (*VPCRouter, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCRoutersGetRouter
//
// Get a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *NetworkingService) VPCRoutersGetRouter(organizationName Name, projectName Name, routerName Name, vpcName Name) (*VPCRouter, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCRoutersPutRouter
//
// Update a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *NetworkingService) VPCRoutersPutRouter(organizationName Name, projectName Name, routerName Name, vpcName Name, j *VPCRouterUpdate) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// VPCRoutersDeleteRouter
//
// Delete a router from its VPC
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *NetworkingService) VPCRoutersDeleteRouter(organizationName Name, projectName Name, routerName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// RoutersRoutesList
//
// List a Router's routes
//
// To iterate over all pages, use the `RoutersRoutesListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `organizationName`
//	- `pageToken`
//	- `projectName`
//	- `routerName`
//	- `sortBy`
//	- `vpcName`
func (s *NetworkingService) RoutersRoutesList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, routerName Name, vpcName Name) (*RouterRouteResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"routerName":       string(routerName),
		"sortBy":           string(sortBy),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterRouteResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// RoutersRoutesListAllPages
//
// List a Router's routes
//
// This method is a wrapper around the `RoutersRoutesList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `sortBy`
//	- `vpcName`
func (s *NetworkingService) RoutersRoutesListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, routerName Name, vpcName Name) (*[]RouterRoute, error) {

	var allPages []RouterRoute
	pageToken := ""
	limit := 100
	for {
		page, err := s.RoutersRoutesList(limit, pageToken, sortBy, organizationName, projectName, routerName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // RoutersRoutesCreate
//
// Create a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *NetworkingService) RoutersRoutesCreate(organizationName Name, projectName Name, routerName Name, vpcName Name, j *RouterRouteCreateParams) (*RouterRoute, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// RoutersRoutesGetRoute
//
// Get a VPC Router route
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
func (s *NetworkingService) RoutersRoutesGetRoute(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name) (*RouterRoute, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routeName":        string(routeName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// RoutersRoutesPutRoute
//
// Update a Router route
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
func (s *NetworkingService) RoutersRoutesPutRoute(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name, j *RouterRouteUpdateParams) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routeName":        string(routeName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// RoutersRoutesDeleteRoute
//
// Delete a route from its router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
func (s *NetworkingService) RoutersRoutesDeleteRoute(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"routeName":        string(routeName),
		"routerName":       string(routerName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// VPCSubnetsList
//
// List subnets in a VPC.
//
// To iterate over all pages, use the `VPCSubnetsListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `organizationName`
//	- `pageToken`
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *NetworkingService) VPCSubnetsList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*VPCSubnetResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCSubnetResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCSubnetsListAllPages
//
// List subnets in a VPC.
//
// This method is a wrapper around the `VPCSubnetsList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *NetworkingService) VPCSubnetsListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*[]VPCSubnet, error) {

	var allPages []VPCSubnet
	pageToken := ""
	limit := 100
	for {
		page, err := s.VPCSubnetsList(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // VPCSubnetsCreate
//
// Create a subnet in a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *NetworkingService) VPCSubnetsCreate(organizationName Name, projectName Name, vpcName Name, j *VPCSubnetCreate) (*VPCSubnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCSubnetsGetSubnet
//
// Get subnet in a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (s *NetworkingService) VPCSubnetsGetSubnet(organizationName Name, projectName Name, subnetName Name, vpcName Name) (*VPCSubnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"subnetName":       string(subnetName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// VPCSubnetsPutSubnet
//
// Update a VPC Subnet.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (s *NetworkingService) VPCSubnetsPutSubnet(organizationName Name, projectName Name, subnetName Name, vpcName Name, j *VPCSubnetUpdate) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"subnetName":       string(subnetName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// VPCSubnetsDeleteSubnet
//
// Delete a subnet from a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (s *NetworkingService) VPCSubnetsDeleteSubnet(organizationName Name, projectName Name, subnetName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organizationName": string(organizationName),
		"projectName":      string(projectName),
		"subnetName":       string(subnetName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// SubnetsIpsList
//
// List IP addresses on a VPC subnet.
//
// To iterate over all pages, use the `SubnetsIpsListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `organizationName`
//	- `pageToken`
//	- `projectName`
//	- `sortBy`
//	- `subnetName`
//	- `vpcName`
func (s *NetworkingService) SubnetsIpsList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, subnetName Name, vpcName Name) (*NetworkInterfaceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}/ips"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":            strconv.Itoa(limit),
		"organizationName": string(organizationName),
		"pageToken":        pageToken,
		"projectName":      string(projectName),
		"sortBy":           string(sortBy),
		"subnetName":       string(subnetName),
		"vpcName":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// SubnetsIpsListAllPages
//
// List IP addresses on a VPC subnet.
//
// This method is a wrapper around the `SubnetsIpsList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
//	- `subnetName`
//	- `vpcName`
func (s *NetworkingService) SubnetsIpsListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, subnetName Name, vpcName Name) (*[]NetworkInterface, error) {

	var allPages []NetworkInterface
	pageToken := ""
	limit := 100
	for {
		page, err := s.SubnetsIpsList(limit, pageToken, sortBy, organizationName, projectName, subnetName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // List
//
// List the built-in roles
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
func (s *RolesService) List(limit int, pageToken string) (*RoleResultsPage, error) {
	// Create the url.
	path := "/roles"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RoleResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages
//
// List the built-in roles
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
func (s *RolesService) ListAllPages() (*[]Role, error) {

	var allPages []Role
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get
//
// Fetch a specific built-in role
//
// Parameters:
//	- `roleName`
func (s *RolesService) Get(roleName string) (*Role, error) {
	// Create the url.
	path := "/roles/{{.role_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"roleName": roleName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Role
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List
//
// List all sagas (for debugging)
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
func (s *SagasService) List(limit int, pageToken string, sortBy IDSortMode) (*SagaResultsPage, error) {
	// Create the url.
	path := "/sagas"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
		"sortBy":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SagaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages
//
// List all sagas (for debugging)
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *SagasService) ListAllPages(sortBy IDSortMode) (*[]Saga, error) {

	var allPages []Saga
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get
//
// Fetch information about a single saga (for debugging)
//
// Parameters:
//	- `sagaId`
func (s *SagasService) Get(sagaId string) (*Saga, error) {
	// Create the url.
	path := "/sagas/{{.saga_id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sagaId": sagaId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Saga
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// TimeseriesSchemaList
//
// List all timeseries schema
//
// To iterate over all pages, use the `TimeseriesSchemaListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
func (s *MetricsService) TimeseriesSchemaList(limit int, pageToken string) (*TimeseriesSchemaResultsPage, error) {
	// Create the url.
	path := "/timeseries/schema"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body TimeseriesSchemaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// TimeseriesSchemaListAllPages
//
// List all timeseries schema
//
// This method is a wrapper around the `TimeseriesSchemaList` method.
// This method returns all the pages at once.
func (s *MetricsService) TimeseriesSchemaListAllPages() (*[]TimeseriesSchema, error) {

	var allPages []TimeseriesSchema
	pageToken := ""
	limit := 100
	for {
		page, err := s.TimeseriesSchemaList(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // List
//
// List the built-in system users
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`
//	- `pageToken`
//	- `sortBy`
func (s *UsersService) List(limit int, pageToken string, sortBy NameSortMode) (*UserResultsPage, error) {
	// Create the url.
	path := "/users"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":     strconv.Itoa(limit),
		"pageToken": pageToken,
		"sortBy":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages
//
// List the built-in system users
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *UsersService) ListAllPages(sortBy NameSortMode) (*[]User, error) {

	var allPages []User
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get
//
// Fetch a specific built-in system user
//
// Parameters:
//	- `userName`
func (s *UsersService) Get(userName Name) (*User, error) {
	// Create the url.
	path := "/users/{{.user_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"userName": string(userName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}
